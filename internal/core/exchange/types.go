// Package exchange содержит типы и интерфейсы для работы с биржами
package exchange

// ============================================================================
// Exchange Identifiers
// ============================================================================

// Exchange IDs - уникальные идентификаторы для каждой биржи
// Используются для маршрутизации запросов к нужному драйверу и в логах
const (
	Binance = "binance" // Binance (крупнейшая централизованная биржа)
	Bybit   = "bybit"   // Bybit (развивающаяся биржа с хорошей ликвидностью)
	OKX     = "okx"     // OKX (полнофункциональная биржа с множеством торговых пар)
	Kucoin  = "kucoin"  // KuCoin (биржа с уникальными альткойнами)
	Coinex  = "coinex"  // Coinex (биржа с низкими комиссиями)
	HTX     = "htx"     // HTX (Huobi Global, ребрендинг Huobi)
	MEXC    = "mexc"    // MEXC (биржа с большим количеством пар)
	DEX     = "dex"     // DEX (децентрализованная биржа, заполнитель для будущих DEX)
)

// ============================================================================
// Market Types
// ============================================================================

// MarketType - тип рынка на бирже
// Разные рынки имеют разные WS endpoints и API, требуют отдельных соединений
const (
	MarketSpot    = "spot"    // Спот-торговля: купля-продажа реальных активов
	MarketFutures = "futures" // Фьючерсы: торговля с кредитным плечом, перпетуальные контракты
)

// ============================================================================
// Level - один уровень в книге ордеров (bid/ask)
// ============================================================================

// Level представляет один уровень цены в книге ордеров
// Содержит цену и объем на этой цене
type Level struct {
	// Price - цена за одну единицу актива
	// Для BTC/USDT это будет цена в USDT
	// Тип float64 позволяет работать с дробными ценами (например, 45123.56)
	Price float64

	// Amount - объем активов на данной цене
	// Для BTC/USDT это будет количество BTC доступно по цене Price
	// Если Amount = 0, это означает что данный уровень удален
	Amount float64
}

// ============================================================================
// OrderBook - текущая книга ордеров для торговой пары на бирже
// ============================================================================

// OrderBook содержит полную информацию о текущем состоянии книги ордеров
// Используется для хранения и обновления данных по паре
type OrderBook struct {
	// === Идентификация ===

	// ExchangeID - ID биржи (binance, bybit, okx и т.д.)
	// Определяет какой драйвер использовал этот orderbook
	ExchangeID string

	// Pair - торговая пара в формате "BTC/USDT"
	// Стандартный формат: ОСНОВНОЙ_АКТИВ/КОТИРУЕМЫЙ_АКТИВ
	// Примеры: "BTC/USDT", "ETH/USDT", "SOL/USDT"
	Pair string

	// MarketType - тип рынка: "spot" или "futures"
	// Определяет какой тип торговли (спот или фьючерсы)
	MarketType string

	// === Данные книги ордеров ===

	// Bids - массив уровней цены покупателей (спросы на покупку)
	// Отсортирован по цене в убывающем порядке (самая высокая цена первой)
	// Bids[0] = лучшая цена покупателя (Best Bid)
	// Пример для BTC/USDT: [45000.00, 44999.50, 44999.00, ...]
	Bids []Level

	// Asks - массив уровней цены продавцов (предложения на продажу)
	// Отсортирован по цене в возрастающем порядке (самая низкая цена первой)
	// Asks[0] = лучшая цена продавца (Best Ask)
	// Пример для BTC/USDT: [45001.00, 45001.50, 45002.00, ...]
	Asks []Level

	// Depth - глубина книги ордеров (количество уровней)
	// Возможные значения:
	// - 20 = 20 лучших bid + 20 лучших ask (самое быстрое, лучше для скорости)
	// - 50 = 50 лучших bid + 50 лучших ask (среднее, хороший баланс)
	// - 0 = полная книга ордеров (все уровни, самое медленное но полнейшие данные)
	Depth int

	// === Метаинформация ===

	// Timestamp - время обновления в Unix микросекундах (microseconds)
	// Когда это сообщение было создано биржей
	// Например: 1702274400000000 = 2023-12-11 12:00:00 UTC
	// Стандартный формат для HFT систем: достаточная точность и легкая конверсия
	// Конверсия: ms × 1000 = μs, ns ÷ 1000 = μs
	// Используется для синхронизации времени и проверки свежести данных
	Timestamp int64

	// SeqNum - порядковый номер обновления от биржи
	// Определяет порядок обновлений для одной пары на конкретной бирже
	// Если текущий SeqNum <= предыдущий, то это старое или дублирующееся сообщение
	// Каждая биржа использует свою последовательность, начиная с разных значений
	// На некоторых биржах SeqNum привязан к временным меткам, на других - независимый
	SeqNum int64
}

// ============================================================================
// MonitoringTask - задача мониторинга конкретной пары на бирже
// ============================================================================

// MonitoringTask содержит информацию о какую пару нужно мониторить
// Загружается из MySQL таблицы MONITORING
// Monitor (роль демона) используется для сбора исторических данных в ClickHouse
type MonitoringTask struct {
	// ID - уникальный ID в таблице MONITORING
	// Используется для обновления конфига в БД
	ID int

	// UID - ID пользователя
	// Определяет кому принадлежит эта конфигурация мониторинга
	UID int

	// ExchangeID - ID биржи (binance, bybit, okx и т.д.)
	// Определяет на какой бирже мониторить
	ExchangeID string

	// ExchangeName - читаемое название биржи (Binance, Bybit, OKX и т.д.)
	// Используется в логах и UI для удобства
	ExchangeName string

	// MarketType - тип рынка (spot или futures)
	// Определяет какой рынок мониторить
	// На разных рынках разные WS endpoints
	MarketType string

	// TradePairID - ID торговой пары в нашей базе данных
	// Используется для связи с таблицей торговых пар
	// Позволяет хранить доп информацию о паре в другой таблице
	TradePairID int

	// TradePair - торговая пара в формате "BTC/USDT"
	// Что именно мониторим
	TradePair string

	// === Параметры мониторинга (из таблицы MONITORING) ===

	// OrderbookDepth - желаемая глубина orderbook
	// Стандартные значения: 20, 50 или 0 (полная книга)
	// Влияет на размер сообщений и объем данных
	OrderbookDepth int

	// BatchSize - количество событий для батча перед отправкой в ClickHouse
	// Пример: 1000 означает что после 1000 событий отправляем в БД
	BatchSize int

	// BatchIntervalSec - максимальный интервал отправки батча в секундах
	// Пример: 300 означает что даже если меньше 1000 событий, отправляем через 5 минут
	BatchIntervalSec int

	// RingBufferSize - размер циклического буфера для хранения в памяти
	// Пример: 10000 означает что храним последние 10000 обновлений
	// Если буфер переполнится, старые данные перезаписываются новыми
	RingBufferSize int

	// SaveIntervalSec - интервал сохранения snapshots в ClickHouse (в секундах)
	// Пример: 600 означает что сохраняем полный снимок книги каждые 10 минут
	SaveIntervalSec int
}

// ============================================================================
// TradingTask - задача торговли конкретной пары на бирже
// ============================================================================

// TradingTask содержит информацию о какую пару нужно торговать и какой стратегией
// Загружается из MySQL таблицы TRADE
// Trader (роль демона) использует это для выполнения торговых операций
type TradingTask struct {
	// === Идентификация ===

	// ID - уникальный ID в таблице TRADE
	// Используется для обновления статуса в БД
	ID int

	// UID - ID пользователя
	// Определяет кому принадлежит эта торговая конфигурация
	UID int

	// TradeType - ID типа стратегии (из таблицы TRADE_TYPE)
	// Числовой ID: 1=manual, 2=grid, 5=market making, 6=arbitrage и т.д.
	// Используется для связи с базой данных
	TradeType int

	// ExchangeID - ID биржи (binance, bybit, okx и т.д.)
	// Определяет на какой бирже торговать
	ExchangeID string

	// ExchangeName - читаемое название биржи
	// Используется в логах для удобства
	ExchangeName string

	// MarketType - тип рынка (spot или futures)
	// Определяет какой рынок торговать
	// Спот = реальные деньги, фьючерсы = с кредитным плечом
	MarketType string

	// === Пара и стратегия ===

	// TradePairID - ID торговой пары в нашей базе
	// Используется для связи с доп информацией о паре
	TradePairID int

	// TradePair - торговая пара в формате "BTC/USDT"
	// Что торгуем
	TradePair string

	// StrategyID - уникальный ID стратегии (grid, dca, momentum и т.д.)
	// Определяет какую стратегию применять к этой паре
	// Примеры: "grid", "dca", "momentum", "arbitrage"
	StrategyID string

	// === Параметры торговли (из таблицы TRADE) ===

	// StrategyParams - параметры стратегии в виде JSON строки
	// Содержит конфигурацию для конкретной стратегии
	// Примеры для grid стратегии:
	// {
	//   "grid_step": 0.5,
	//   "order_size": 100.0,
	//   "layers": 10,
	//   "max_open_orders": 50
	// }
	// Парсится при загрузке в зависимости от StrategyID
	StrategyParams string

	// ExchangeAccountID - ID API ключа для этой биржи
	// Определяет какой аккаунт на бирже использовать для ордеров
	// Пользователь может иметь несколько API ключей на одной бирже
	ExchangeAccountID int
}

// TasksData - объединение всех задач, загруженных из MySQL
// ============================================================================

// TasksData используется при периодической загрузке задач из БД
// Содержит как задачи мониторинга, так и задачи торговли
// На основе этих данных вычисляется какие пары подписать/отписать в WS
type TasksData struct {
	// Timestamp - когда были загружены эти задачи
	// Используется для отслеживания свежести данных
	Timestamp int64

	// MonitoringTasks - список пар для мониторинга
	// Может быть пусто если демон работает только в режиме трейдера
	MonitoringTasks []*MonitoringTask

	// TradingTasks - список пар для торговли
	// Может быть пусто если демон работает только в режиме монитора
	TradingTasks []*TradingTask
}

// ============================================================================
// Вспомогательные функции для работы с типами
// ============================================================================

// GetOrderBookKey возвращает уникальный ключ для orderbook
// Используется в map[string]*OrderBook для быстрого поиска
func GetOrderBookKey(exchangeID, pair, marketType string) string {
	return exchangeID + ":" + marketType + ":" + pair
}

// GetMonitoringTaskKey возвращает уникальный ключ для задачи
// Используется для дедупликации и сравнения задач
func GetMonitoringTaskKey(task MonitoringTask) string {
	return task.ExchangeID + ":" + task.MarketType + ":" + task.TradePair
}

// GetTradingTaskKey возвращает уникальный ключ для торговой задачи
func GetTradingTaskKey(task TradingTask) string {
	return task.ExchangeID + ":" + task.MarketType + ":" + task.TradePair + ":" + task.StrategyID
}
