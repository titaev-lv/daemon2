// Package messaging содержит единый формат сообщений от всех бирж
package messaging

// ============================================================================
// Message Types - константы для типов сообщений от бирж
// ============================================================================

// Тип сообщения определяет какие данные содержит Message
// Используется для маршрутизации сообщения к нужному обработчику
const (
	TypeOrderBook = "orderbook" // Обновление книги ордеров (самое частое)
	TypeTrade     = "trade"     // Новая сделка (реальная торговля на бирже)
	TypePosition  = "position"  // Обновление позиции (для трейдера)
	TypeOrder     = "order"     // Обновление статуса ордера (мой ордер исполнен и т.д.)
)

// ============================================================================
// Level - один уровень цены в книге ордеров
// ============================================================================

// Level содержит цену и объем на этой цене
// Используется внутри OrderBookData для представления bid/ask
type Level struct {
	// Price - цена за одну единицу актива
	Price float64
	// Amount - объем на этой цене (0 = уровень удален)
	Amount float64
}

// ============================================================================
// Message - единый формат сообщения от всех бирж
// ============================================================================

// Message - основная структура для всех сообщений от бирж
// Преобразуется из специфичного для каждой биржи формата в этот унифицированный
// Позволяет одним кодом обрабатывать данные со всех бирж
type Message struct {
	// === Основная информация ===

	// Timestamp - время события в Unix микросекундах (microseconds)
	// Конвертируется в формат Unix μs при парсинге сообщения от биржи
	// Пример: 1702274400000000 = 2023-12-11 12:00:00 UTC
	// Стандартный формат для HFT: достаточная точность для всех бирж
	// Конверсия: ms × 1000 = μs, ns ÷ 1000 = μs
	// Всегда в UTC, не зависит от часового пояса
	Timestamp int64

	// ExchangeID - ID биржи которая отправила это сообщение
	// Значения: "binance", "bybit", "okx", "kucoin", "coinex", "htx", "mexc", "dex"
	// Используется для идентификации источника данных
	ExchangeID string

	// MarketType - тип рынка (spot или futures)
	// Определяет какой рынок связан с этим сообщением
	MarketType string

	// Type - тип сообщения (orderbook, trade, position, order)
	// Определяет какое из полей ниже заполнено
	// Остальные поля будут nil
	Type string

	// === Информация о паре ===

	// Pair - торговая пара в стандартном формате "BTC/USDT"
	// Конвертируется из формата конкретной биржи (btcusdt -> BTC/USDT)
	Pair string

	// SeqNum - порядковый номер обновления от биржи
	// Используется для детектирования потери сообщений
	// Если получили SeqNum=100, потом 102, потеряли одно сообщение
	SeqNum int64

	// === Type-specific данные (зависит от Type) ===

	// OrderBook - данные для типа "orderbook"
	// Содержит актуальную книгу ордеров (bid/ask уровни)
	// Заполнено ТОЛЬКО если Type == TypeOrderBook
	OrderBook *OrderBookData

	// Trade - данные для типа "trade"
	// Содержит информацию о новой сделке на бирже
	// Заполнено ТОЛЬКО если Type == TypeTrade
	Trade *TradeData

	// Position - данные для типа "position"
	// Содержит информацию о текущей позиции трейдера
	// Заполнено ТОЛЬКО если Type == TypePosition
	Position *PositionData

	// Order - данные для типа "order"
	// Содержит информацию об исполнении моего ордера
	// Заполнено ТОЛЬКО если Type == TypeOrder
	Order *OrderData
}

// ============================================================================
// OrderBookData - данные для сообщений типа "orderbook"
// ============================================================================

// OrderBookData содержит актуальное состояние книги ордеров
// Может быть дельта (только изменения) или полный снимок
type OrderBookData struct {
	// Bids - уровни цены покупателей (спросы на покупку)
	// Отсортирован по цене в убывающем порядке
	// Bids[0] = Best Bid (лучшая цена покупателя)
	// Пример для BTC/USDT:
	// Bids[0] = {Price: 45000.00, Amount: 2.5}  (лучшая цена, 2.5 BTC)
	// Bids[1] = {Price: 44999.50, Amount: 1.2}
	// Bids[2] = {Price: 44999.00, Amount: 0.8}
	Bids []Level

	// Asks - уровни цены продавцов (предложения на продажу)
	// Отсортирован по цене в возрастающем порядке
	// Asks[0] = Best Ask (лучшая цена продавца)
	// Пример для BTC/USDT:
	// Asks[0] = {Price: 45001.00, Amount: 3.0}  (лучшая цена, 3.0 BTC)
	// Asks[1] = {Price: 45001.50, Amount: 1.5}
	// Asks[2] = {Price: 45002.00, Amount: 2.0}
	Asks []Level

	// Depth - глубина книги ордеров (сколько уровней)
	// Значения:
	// - 20 = 20 уровней (быстро, для стратегий требующих скорости)
	// - 50 = 50 уровней (баланс между скоростью и полнотой)
	// - 0 = полная книга (самая полная информация, но медленнее)
	// Примечание: количество уровней может быть < Depth если меньше уровней в реальности
	Depth int
}

// ============================================================================
// TradeData - данные для сообщений типа "trade"
// ============================================================================

// TradeData содержит информацию о реальной сделке на бирже
// Это сделка между другими трейдерами (не моя)
// Используется для анализа потока ордеров и объемов
type TradeData struct {
	// Price - цена сделки
	// По какой цене произошла сделка
	Price float64

	// Amount - объем сделки
	// Количество актива которое торговалось
	Amount float64

	// Side - направление сделки с точки зрения инициатора
	// "buy" = покупатель инициировал сделку (взял ask)
	// "sell" = продавец инициировал сделку (взял bid)
	// Используется для анализа направления тренда (aggressor side)
	Side string
}

// ============================================================================
// PositionData - данные для сообщений типа "position"
// ============================================================================

// PositionData содержит информацию о текущей позиции трейдера
// Приватная информация (требует аутентификации)
// Используется в приватном WebSocket для трэйдера
type PositionData struct {
	// Side - направление позиции
	// "long" = длинная позиция (куплено, ожидаем роста)
	// "short" = короткая позиция (продано в долг, ожидаем падения)
	Side string

	// Amount - объем позиции
	// Количество активов в позиции
	Amount float64

	// EntryPrice - цена входа в позицию
	// По какой цене открыли позицию
	EntryPrice float64

	// CurrentPrice - текущая цена актива
	// Используется для вычисления P&L
	CurrentPrice float64

	// PnL - прибыль/убыток по позиции
	// Вычисляется как (CurrentPrice - EntryPrice) * Amount для long
	// или как (EntryPrice - CurrentPrice) * Amount для short
	PnL float64
}

// ============================================================================
// OrderData - данные для сообщений типа "order"
// ============================================================================

// OrderData содержит информацию об исполнении моего ордера
// Приватная информация (мой ордер)
// Используется в приватном WebSocket для трейдера
type OrderData struct {
	// OrderID - уникальный ID ордера на бирже
	// Присваивается биржей при создании ордера
	// Используется для отслеживания и отмены ордера
	OrderID string

	// Side - направление ордера
	// "buy" = покупаем (лонг)
	// "sell" = продаем (шорт)
	Side string

	// Price - цена заказа
	// Лимит цена для лимит-ордера
	// 0 для маркет-ордера
	Price float64

	// Amount - объем заказа (всего)
	// Сколько активов хотели купить/продать
	Amount float64

	// Filled - объем уже исполненный
	// Сколько уже исполнено
	Filled float64

	// Status - статус ордера
	// "open" = открыт (ждет исполнения)
	// "filled" = полностью исполнен
	// "partially_filled" = частично исполнен
	// "cancelled" = отменен
	// "rejected" = отклонен биржей
	Status string

	// Commission - комиссия по ордеру
	// Сколько взяла биржа за исполнение
	Commission float64
}

// ============================================================================
// Вспомогательные функции
// ============================================================================

// GetMessageKey возвращает уникальный ключ для сообщения
// Используется для дедупликации и логирования
func GetMessageKey(msg *Message) string {
	return msg.ExchangeID + ":" + msg.MarketType + ":" + msg.Pair + ":" + msg.Type
}
